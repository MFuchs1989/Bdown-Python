---
title: Dealing with missing values
author: Michael Fuchs
date: '2019-03-18'
slug: dealing-with-missing-values
categories:
  - R
tags:
  - R Markdown
output:
  blogdown::html_page:
    toc: true
    toc_depth: 5
---

# 1 Introduction


In the real world, there is virtually no record that has no missing values. Dealing with missing values can be done differently. In the following several methods will be presented how to deal with them.


# 2 Loading the Libraries and the Data

```{r, eval=F, echo=T}
import pandas as pd
import numpy as np

from sklearn.impute import SimpleImputer
from sklearn.pipeline import Pipeline

from sklearn.impute import KNNImputer

from sklearn.model_selection import train_test_split
import pickle as pk
import random
```

```{r, eval=F, echo=T}
df = pd.DataFrame({'Name': ['Anton', 'Moni', np.NaN, 'Renate', 'Justus'],
                   'Age': [32,22,62,np.NaN,18],
                   'Salary': [np.NaN, np.NaN,4500,2500,3800],
                   'Job': ['Student', np.NaN, 'Manager', 'Teacher', 'Student']})
df
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p1.png)


# 3 Checking for missing values


```{r, eval=F, echo=T}
df.isnull().sum()
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p2.png)


```{r, eval=F, echo=T}
def mv_overview_func(df):
    '''
    Gives an overview of the total number and percentage of missing values in a data set
    
    Args:
        df (DataFrame): Dataframe to which the function is to be applied
        
    Returns:
        Overview of the total number and percentage of missing values
    '''
    # Total missing values
    mis_val = df.isnull().sum()
    # Percentage of missing values
    mis_val_percent = 100 * df.isnull().sum() / len(df)
    # Data Types
    data_types = df.dtypes
    # Make a table with the results
    mis_val_table = pd.concat([mis_val, mis_val_percent, data_types], axis=1)
    # Rename the columns
    mis_val_table_ren_columns = mis_val_table.rename(
    columns = {0 : 'Missing Values', 1 : '% of Total Values', 2 : 'Data Type'})
    # Sort the table by percentage of missing descending
    mis_val_table_ren_columns = mis_val_table_ren_columns[
        mis_val_table_ren_columns.iloc[:,1] != 0].sort_values(
        '% of Total Values', ascending=False).round(1)
    # Print some summary information
    print ("Your selected dataframe has " + str(df.shape[1]) + " columns.\n"      
            "There are " + str(mis_val_table_ren_columns.shape[0]) +
            " columns that have missing values.")
    # Return the dataframe with missing information
    return mis_val_table_ren_columns
```

```{r, eval=F, echo=T}
mv_overview_func(df)
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p3.png)

# 4 Droping of Missing Values


```{r, eval=F, echo=T}
df_drop = df.copy()
df_drop
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p4.png)


All rows with minimum one NaN will be dropped:

```{r, eval=F, echo=T}
df_drop.dropna()
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p5.png)


All rows from the defined columns with a NaN will be dropped:


```{r, eval=F, echo=T}
df_drop.dropna(subset=['Name', 'Age'])
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p6.png)


# 5 Imputations

## 5.1 for **NUMERIC** Features

### 5.1.1 Replace np.NaN with specific values


```{r, eval=F, echo=T}
df_replace_1 = df.copy()
df_replace_1
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p7.png)


Missing values from only one column (here 'Name') are replaced:


```{r, eval=F, echo=T}
df_replace_1['Name'] = df_replace_1['Name'].fillna(0)
df_replace_1
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p8.png)


Missing values from the complete dataset will be replaced:

```{r, eval=F, echo=T}
df_replace_1.fillna(0, inplace=True)
df_replace_1
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p9.png)


Does that make sense? Probably not. So let's look at imputations that follow a certain logic.


### 5.1.2 Replace np.NaN with MEAN

A popular metric for replacing missing values is the use of mean. 



```{r, eval=F, echo=T}
df_replace_2 = df.copy()
df_replace_2
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p10.png)



```{r, eval=F, echo=T}
df_replace_2['Age'].mean()
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p11.png)


Here all missing values of the column 'Age' are replaced by their mean value.

```{r, eval=F, echo=T}
df_replace_2['Age'] = df_replace_2['Age'].fillna(df_replace_2['Age'].mean())
df_replace_2
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p12.png)


**scikit-learn - SimpleImputer**

Always keep in mind that you will need all the steps you take to prepare for model training to make predictions later. 

What do I mean by that exactly?
If the data set you have available for model training already has missing values, it is quite possible that future data sets for which predictions are to be made will also contain missing values. 
In order for the prediction model to work, these missing values must be replaced by metrics that were also used in the model training. 


```{r, eval=F, echo=T}
df_replace_3 = df.copy()
df_replace_3
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p13.png)


```{r, eval=F, echo=T}
imp_age_mean = SimpleImputer(missing_values=np.nan, strategy='mean')

imp_age_mean.fit(df_replace_3[['Age']])
df_replace_3['Age'] = imp_age_mean.transform(df_replace_3[['Age']])
df_replace_3
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p14.png)


In the steps shown before, I used the .fit and .transform functions separately. If it's not about model training, you can also combine these two steps and save yourself another line of code. 

```{r, eval=F, echo=T}
df_replace_4 = df.copy()
df_replace_4
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p15.png)


```{r, eval=F, echo=T}
imp_age_mean = SimpleImputer(missing_values=np.nan, strategy='mean')

df_replace_4['Age'] = imp_age_mean.fit_transform(df_replace_4[['Age']])
df_replace_4
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p16.png)


This way you can see which value is behind imp_age_mean concretely: 

```{r, eval=F, echo=T}
 imp_age_mean.statistics_
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p17.png)


### 5.1.3 Replace np.NaN with MEDIAN

Other metrics such as the median can also be used instead of missing values:

```{r, eval=F, echo=T}
df_replace_5 = df.copy()
df_replace_5
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p18.png)


```{r, eval=F, echo=T}
imp_age_median = SimpleImputer(missing_values=np.nan, strategy='median')

df_replace_5['Age'] = imp_age_median.fit_transform(df_replace_5[['Age']])
df_replace_5
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p19.png)


```{r, eval=F, echo=T}
imp_age_median.statistics_
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p20.png)


### 5.1.4 Replace np.NaN with most_frequent

For some variables, it makes sense to use the most frequently occurring value for NaNs instead of mean or median. 


```{r, eval=F, echo=T}
df_replace_6 = df.copy()
df_replace_6
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p21.png)



```{r, eval=F, echo=T}
imp_age_mfreq = SimpleImputer(missing_values=np.nan, strategy='most_frequent')

df_replace_6['Age'] = imp_age_mfreq.fit_transform(df_replace_6[['Age']])
df_replace_6
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p22.png)



Since there is no value in the variable 'Age' that occurs twice or more often, the lowest value is automatically taken. The same would apply if there were two equally frequent values.


## 5.2 for **CATEGORICAL** Features

### 5.2.1 Replace np.NaN with most_frequent

The most_frequent function can be used for numeric variables as well as categorical variables. 


```{r, eval=F, echo=T}
df_replace_7 = df.copy()
df_replace_7
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p23.png)



```{r, eval=F, echo=T}
imp_job_mfreq = SimpleImputer(missing_values=np.nan, strategy='most_frequent')

df_replace_7['Job'] = imp_job_mfreq.fit_transform(df_replace_7[['Job']])
df_replace_7
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p24.png)


Here we see that with a frequency of 2, the job 'student' is the most common, so this is used for the missing value here. 

```{r, eval=F, echo=T}
imp_job_mfreq.statistics_
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p25.png)


But what happens if we just don't have a most frequent value in a categorical column like in our example within the column 'Name'?


```{r, eval=F, echo=T}
df_replace_8 = df.copy()
df_replace_8
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p26.png)


```{r, eval=F, echo=T}
imp_name_mfreq = SimpleImputer(missing_values=np.nan, strategy='most_frequent')

df_replace_8['Name'] = imp_name_mfreq.fit_transform(df_replace_8[['Name']])
df_replace_8
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p27.png)


Again, the principle that the lowest value is used applies. In our example, this is the name Anton, since it begins with A and thus comes before all other names in the alphabet. 


### 5.2.2 Replace np.NaN with specific values

```{r, eval=F, echo=T}
df_replace_9 = df.copy()
df_replace_9
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p28.png)


However, we also have the option of using certain values:

```{r, eval=F, echo=T}
imp_job_const = SimpleImputer(missing_values=np.nan, 
                              strategy='constant',
                              fill_value='others')

df_replace_9['Job'] = imp_job_const.fit_transform(df_replace_9[['Job']])
df_replace_9
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p29.png)


## 5.3 for specific Values

Not only a certain kind of values like NaN values can be replaced, this is also possible with specific values. 


### 5.3.1 single values

For the following example we take the last version of the last used data set, here df_replace_9:


```{r, eval=F, echo=T}
df_replace_9
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p30.png)


```{r, eval=F, echo=T}
rep_job_const = SimpleImputer(missing_values='others', 
                              strategy='constant',
                              fill_value='not_in_scope')

df_replace_9['Job'] = rep_job_const.fit_transform(df_replace_9[['Job']])
df_replace_9
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p31.png)


As we can see, 'others' became 'not_in_scope'.


### 5.3.2 multiple values

Unfortunately, we cannot work with lists for multiple values. But with the use of the pipeline function it works. We use for our following example again the last state of the dataset 'df_replace_9':



```{r, eval=F, echo=T}
rep_pipe = Pipeline([('si1',SimpleImputer(missing_values = 'Manager', 
                                          strategy='constant',
                                          fill_value='not_relevant')),
                     ('si2', SimpleImputer(missing_values = 'Teacher', 
                                           strategy='constant', 
                                           fill_value='not_relevant'))])

df_replace_9['Job'] = rep_pipe.fit_transform(df_replace_9[['Job']])
df_replace_9
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p32.png)


In my opinion, however, this approach has two disadvantages. Firstly, the values used are not saved (so cannot be reused automatically) and secondly, this is a lot of code to write. With an if-else function you would be faster:

```{r, eval=F, echo=T}
def rep_func(col):

    if col == 'Student':
        return 'useless'
    if col == 'not_relevant':
        return 'useless'
    else:
        return 'useless'

df_replace_9['Job'] = df_replace_9['Job'].apply(rep_func)
df_replace_9
```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p33.png)


But again, the values used cannot be easily reused. You would have to create your own dictionary. 


# 6 Further Imputation Methods






```{r, eval=F, echo=T}

```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p.png)











```{r, eval=F, echo=T}

```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p.png)































```{r, eval=F, echo=T}

```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p.png)

























```{r, eval=F, echo=T}

```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p.png)

























```{r, eval=F, echo=T}

```

![](/post/2019-03-18-dealing-with-missing-values_files/p4p.png)






