---
title: Automated Notifications
author: Michael Fuchs
date: '2021-03-13'
slug: automated-notifications
categories: []
tags: []
output:
  blogdown::html_page:
    toc: true
    toc_depth: 5
---




# 1 Introduction

Often model training (especially when working with neural networks) takes some time that can be usefully spent on other work. 
Since I would like to be informed immediately when a model training is finished or a certain processing status has been reached, I have listed some of my methods in this post, how such notifications can be made via Python.

For this post the dataset *Bank Data* from the platform ["UCI Machine Learning Repository"](https://archive.ics.uci.edu/ml/datasets/Bank+Marketing) was used. You can download it from my ["GitHub Repository"](https://github.com/MFuchs1989/Datasets-and-Miscellaneous/tree/main/datasets). 


# 2 Import the Libraries and the Data


```{r, eval=F, echo=T}
import pandas as pd
import matplotlib.pyplot as plt
import time

from sklearn.model_selection import train_test_split
from sklearn.svm import SVC


# for chapter 4.2
import winsound
# for chapter 4.3
import telegram
from sklearn.metrics import accuracy_score
from datetime import datetime
from sklearn.model_selection import GridSearchCV
# for chapter 4.4
import pymsteams
# for chapter 4.5 
from keras import models
from keras import layers
## for chapter 4.5.2
from tf_notification_callback import TelegramCallback
## for chapter 4.5.3
import requests
import tensorflow as tf
import tensorflow.keras.utils as np_utils
```


```{r, eval=F, echo=T}
df = pd.read_csv('bank.csv', sep=';')

col_to_keep = 'age','job','marital','education','month','y'

df = df.filter(col_to_keep)
df
```

![](/post/2021-03-13-automated-notifications_files/p131p1.png)



# 3 Data Pre-Processing


## 3.1  Encoding of the Predictors

Here we use the get_dummies function from the pandas library as it is simple and quick to write with just a few lines of code. 

For a real model development you should of course use [OHE from scikit-learn](https://michael-fuchs-python.netlify.app/2019/06/16/types-of-encoder/#via-scikit-learn) to reuse the created encoder (for new or inverse transformations).

In this post, however, not the model training itself is central but the automatic notification at the end of a model training via various channels. 

```{r, eval=F, echo=T}
df = pd.get_dummies(df, prefix=['Job'], columns=['job'])
df = pd.get_dummies(df, prefix=['Marital'], columns=['marital'])
df = pd.get_dummies(df, prefix=['Education'], columns=['education'])
df = pd.get_dummies(df, prefix=['Month'], columns=['month'])

print('Shape of DataFrame: ' + str(df.shape))
print()
print('Columns : ')
print(df.columns)
```

![](/post/2021-03-13-automated-notifications_files/p131p2.png)



## 3.2  Encoding of the Target Variable


```{r, eval=F, echo=T}
vals_to_replace = {'no':'0', 'yes':'1'}
df['target'] = df['y'].map(vals_to_replace)
df['target'] = df.target.astype('int64')

df = df.drop('y', axis=1)

print('Shape of DataFrame: ' + str(df.shape))
print()
print('Columns : ')
print(df.columns)
```

![](/post/2021-03-13-automated-notifications_files/p131p3.png)



## 3.3  Train-Test Split


```{r, eval=F, echo=T}
x = df.drop('target', axis=1)
y = df['target']

trainX, testX, trainY, testY = train_test_split(x, y, test_size = 0.2)
```


# 4 Get Automated Notifications

Here I start a simple model training ([classification using Support Vector Machines](https://michael-fuchs-python.netlify.app/2019/11/08/introduction-to-support-vector-machines/)) which gives me feedback on the processing time in the notebook using the print function.

```{r, eval=F, echo=T}
start = time.time()

clf = SVC(kernel='linear')
clf.fit(trainX, trainY)

end = time.time()

print()
print('Processing Time: ' + str(round(end - start,2)) + ' seconds')
```

![](/post/2021-03-13-automated-notifications_files/p131p4.png)

Of course, I only see this information when I am actively looking at the notebook. But now I want to use methods where I get notifications no matter what activity I am doing on the PC or elsewhere.



## 4.1 via Notify

Notify is an extension for Jupyter Notebook that notifies the user via a browser notification as soon as a code cell has finished its execution. Notify is supported by both Chrome and Firefox. I found this package in this [repo](https://github.com/ShopRunner/jupyter-notify).


**Installation and Enabling:**

How to add new libraries to an existing environment is described [here](https://michael-fuchs-python.netlify.app/2019/01/05/getting-started-with-anaconda/#installing-new-libraries).

`pip install jupyternotify`

Now we **have to enable this** Jupyter Notebook Extension:

`%load_ext jupyternotify`

Your browser will ask you at this point if you want to allow these notifications. Of course, we answer this with yes. 




```{r, eval=F, echo=T}
%%notify

clf = SVC(kernel='linear')
clf.fit(trainX, trainY)
```

![](/post/2021-03-13-automated-notifications_files/p131p5.png)


Personally, when you put multiple notifications in your code lines, I always find it quite useful to add a notification text. 


```{r, eval=F, echo=T}
%%notify -m "Model Training finished"

clf = SVC(kernel='linear')
clf.fit(trainX, trainY)
```

![](/post/2021-03-13-automated-notifications_files/p131p6.png)



## 4.2 via an Audible Signal


Here is another method, where I don't receive text messages, but acoustic signals. 

```{r, eval=F, echo=T}
def make_noise_func():
    '''
    A function to send an acoustic signal
    
    Args:
        none
    
    Returns:
        An acoustic signal
    '''
    # Specification in Milliseconds  
    duration = 1000  
    # Specification in Hertz
    freq = 440  
    winsound.Beep(freq, duration)
```

```{r, eval=F, echo=T}
clf = SVC(kernel='linear')
clf.fit(trainX, trainY)

make_noise_func()
```



## 4.3 via Telegram

### 4.3.1 Set up a Chat Bot

[Telegram](https://telegram.org/) is a popular and widely used text messenger that can also be used to set up a bot and receive messages from Python. Prerequisite is of course that you have Telegram. Otherwise, download the app and follow these steps to set up our bot.

Here is the command with which you can load the library in Python. If you don't know how to do that, read this post of mine: [Getting Started with Anaconda](https://michael-fuchs-python.netlify.app/2019/01/05/getting-started-with-anaconda/)

`conda install -c conda-forge python-telegram-bot`


Now open the app and start a new conversation. Here you type @BotFather.

![](/post/2021-03-13-automated-notifications_files/p131p7.png)


Once you have started the conversation with BotFather, type /newbot.

![](/post/2021-03-13-automated-notifications_files/p131p8.png)


Now you will be asked by the bot to enter a name and then the username which must end in bot. 
Finally, we get the HTTP tokens (outlined in red in the image below), which we will need later.

![](/post/2021-03-13-automated-notifications_files/p131p9.png)

So far we have the following information:

+ Botname: mf-test-bot-20210313
+ Username: mf_20210313_bot
+ HTTP-Token: 1807598377:AAFgcK1MzqIhpw6cFeS0zQ5WVcjoEmetBUM





Now we only need the chat ID. 
To find it out, we need to start a chat with the generated bot. Start a new conversation and search for the username (in our case @mf_20210313_bot).

![](/post/2021-03-13-automated-notifications_files/p131p11.png)


It's really important that you put a two text message in this chat. The content does not matter, but there must be messages in the chat, otherwise the next step will not work. 

![](/post/2021-03-13-automated-notifications_files/p131p12.png)


Now enter the following address into your browser: 

+ https://api.telegram.org/bot[HTTP-TOKEN]/getUpdates. 

Replace [HTTP-TOKEN] with your generated token like here: 

+ https://api.telegram.org/bot1807598377:AAFgcK1MzqIhpw6cFeS0zQ5WVcjoEmetBUM/getUpdates


Now you get a similar view from which you can write out the chat ID (I marked it blue in the picture). 

![](/post/2021-03-13-automated-notifications_files/p131p10.png)


Now we have all the information we need. 

+ Botname: mf-test-bot-20210313
+ Username: mf_20210313_bot
+ HTTP-Token: 1807598377:AAFgcK1MzqIhpw6cFeS0zQ5WVcjoEmetBUM
+ Chat-ID: 1870661656

**Make sure that no one else knows the chat ID and token otherwise they can easily hack into your chat. I will also delete the bot again at the end of this post.** 


Now let's try sending text messages. I have written the following function (chat id and token must be customized of course). 

```{r, eval=F, echo=T}
def telegram_message_func(text):
    '''
    A function for writing Telegram messages
    
    Args:
        text (str): Text message which should be sent, string
    
    Returns:
        A Telegram message with the corresponding text as content
    ''' 
    bot_token = '1807598377:AAFgcK1MzqIhpw6cFeS0zQ5WVcjoEmetBUM'
    chat_id = 1870661656
    
    bot = telegram.Bot(token=bot_token)
    bot.send_message(chat_id=chat_id, text = text)
```

```{r, eval=F, echo=T}
telegram_message_func('Hi There !')
```

![](/post/2021-03-13-automated-notifications_files/p131p13.png)

Works, great ! Now a little gimmick how to add a suitable photo to your bot for example. Go to the chat with the BotFather and enter /setuserpic. 

![](/post/2021-03-13-automated-notifications_files/p131p14.png)


Now you can choose a photo of your choice.

![](/post/2021-03-13-automated-notifications_files/p131p15.png)


This will now appear as the profile picture for your bot. 

![](/post/2021-03-13-automated-notifications_files/p131p16.png)


Below I will show some options of what content you can send everything to Telegram now.


### 4.3.2 Simple Notification


```{r, eval=F, echo=T}
telegram_message_func('Start of the Model Training')

clf = SVC(kernel='linear')
clf.fit(trainX, trainY)

y_pred = clf.predict(testX)

telegram_message_func('End of the Model Training')
```

![](/post/2021-03-13-automated-notifications_files/p131p17.png)



### 4.3.3 Notification with DateTime


```{r, eval=F, echo=T}
current_time_start = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
telegram_message_func('Start of the Model Training. DateTime: ' + str(current_time_start))

# Model Training:
clf = SVC(kernel='linear')
clf.fit(trainX, trainY)

current_time_end = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
telegram_message_func('End of the Model Training. DateTime: ' + str(current_time_end))
```

![](/post/2021-03-13-automated-notifications_files/p131p18.png)

Here the output is displayed even nicer with line break:


```{r, eval=F, echo=T}
current_time_start = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
telegram_message_func('Start of the Model Training. \nDateTime: ' + str(current_time_start))

# Model Training:
clf = SVC(kernel='linear')
clf.fit(trainX, trainY)

current_time_end = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
telegram_message_func('End of the Model Training. \nDateTime: ' + str(current_time_end))
```

![](/post/2021-03-13-automated-notifications_files/p131p19.png)


### 4.3.4 Notification with DateTime and Processing Time


```{r, eval=F, echo=T}
start = time.time()
current_time_start = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
telegram_message_func('Start of the Model Training. \nDateTime: ' + str(current_time_start))

# Model Training:
start = time.time()
clf = SVC(kernel='linear')
clf.fit(trainX, trainY)
end = time.time()

current_time_end = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
telegram_message_func('End of the Model Training. \nDateTime: ' + str(current_time_end))

# Processing Time:

processing_time_sec = round(end - start,2)
processing_time_min = round((end - start)/60, 2)
processing_time_h = round((end - start)/3600, 2)

telegram_message_func('Processing Time: \n' + \
                      str(processing_time_sec) + ' Seconds \n' + \
                      str(processing_time_min) + ' Minutes \n' + \
                      str(processing_time_h) + ' Hours')
```

![](/post/2021-03-13-automated-notifications_files/p131p20.png)



### 4.3.5 Notification with DateTime, Processing Time and Evaluation

```{r, eval=F, echo=T}
start = time.time()
current_time_start = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
telegram_message_func('Start of the Model Training. \nDateTime: ' + str(current_time_start))

# Model Training:
start = time.time()
clf = SVC(kernel='linear')
clf.fit(trainX, trainY)
end = time.time()

current_time_end = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
telegram_message_func('End of the Model Training. \nDateTime: ' + str(current_time_end))

# Processing Time:

processing_time_sec = round(end - start,2)
processing_time_min = round((end - start)/60, 2)
processing_time_h = round((end - start)/3600, 2)

telegram_message_func('Processing Time: \n' + \
                      str(processing_time_sec) + ' Seconds \n' + \
                      str(processing_time_min) + ' Minutes \n' + \
                      str(processing_time_h) + ' Hours')


# Evaluation:
y_pred = clf.predict(testX)
clf_acc = round(accuracy_score(testY, y_pred),2)

telegram_message_func('Accuracy: ' + str(clf_acc) + '%')
```

![](/post/2021-03-13-automated-notifications_files/p131p21.png)

Now we run the model training with GridSearch.

```{r, eval=F, echo=T}
start = time.time()
current_time_start = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
telegram_message_func('Start of the Model Training. \nDateTime: ' + str(current_time_start))

# Model Training:
start = time.time()

param_grid = {'C': [0.1, 1, 3],  
              'gamma': [1, 0.1, 0.01, 0.001, 0.0001], 
              'kernel': ['linear', 'rbf']}
grid = GridSearchCV(SVC(), param_grid, cv = 10, scoring='accuracy', n_jobs=-1)

grid.fit(trainX, trainY)
end = time.time()

current_time_end = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
telegram_message_func('End of the Model Training. \nDateTime: ' + str(current_time_end))

# Processing Time:

processing_time_sec = round(end - start,2)
processing_time_min = round((end - start)/60, 2)
processing_time_h = round((end - start)/3600, 2)

telegram_message_func('Processing Time: \n' + \
                      str(processing_time_sec) + ' Seconds \n' + \
                      str(processing_time_min) + ' Minutes \n' + \
                      str(processing_time_h) + ' Hours')


# Evaluation:
grid_predictions = grid.predict(testX) 
grid_clf_acc = round(accuracy_score(testY, grid_predictions),2)

telegram_message_func('Accuracy with GridSearch: ' + str(grid_clf_acc) + '%')
```

![](/post/2021-03-13-automated-notifications_files/p131p23.png)


### 4.3.6 Delete a Chat Bot

As I mentioned before, I will delete the bot again after this post. This goes as follows. Go to the chat with the BotFather and type /deletebot. 

![](/post/2021-03-13-automated-notifications_files/p131p24.png)

Now you can select the bot you want to delete and confirm it by typing 'Yes, I am totally sure.'. Make sure that you have written everything correctly otherwise it will not work.




## 4.4 via MS Teams



```{r, eval=F, echo=T}

```

![](/post/2021-03-13-automated-notifications_files/p131p.png)



### 4.4.1 Create Incoming Webhook


```{r, eval=F, echo=T}

```

![](/post/2021-03-13-automated-notifications_files/p131p.png)






### 4.4.2 Simple Notification



```{r, eval=F, echo=T}

```

![](/post/2021-03-13-automated-notifications_files/p131p.png)




### 4.4.3 Notification with DateTime, Processing Time and Evaluation





```{r, eval=F, echo=T}

```

![](/post/2021-03-13-automated-notifications_files/p131p.png)


### 4.4.4 Delete the Webhook




```{r, eval=F, echo=T}

```

![](/post/2021-03-13-automated-notifications_files/p131p.png)


## 4.5 via TensorFlow Notification Callback






```{r, eval=F, echo=T}

```

![](/post/2021-03-13-automated-notifications_files/p131p.png)



### 4.5.1 Preparation Model Training



```{r, eval=F, echo=T}

```

![](/post/2021-03-13-automated-notifications_files/p131p.png)


### 4.5.2 One Time Notifications


```{r, eval=F, echo=T}

```

![](/post/2021-03-13-automated-notifications_files/p131p.png)



### 4.5.3 Ongoing Notifications




```{r, eval=F, echo=T}

```

![](/post/2021-03-13-automated-notifications_files/p131p.png)






# 5 Conclusion












